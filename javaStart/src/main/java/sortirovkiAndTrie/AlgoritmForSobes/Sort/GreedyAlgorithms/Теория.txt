Greedy Algorithms
Жадный алгоритм — это подход, при котором на каждом этапе принимаются локально оптимальные решения и допускается, что конечное решение также окажется оптимальным. “Оптимальное” решение — то, которое предлагает наиболее очевидную и немедленную выгоду на определенном шаге/этапе.

Чтобы рассмотреть данный алгоритм, выберем довольно распространенную задачу — о рюкзаке.

Давайте на секунду представим, что вы вор. Вы вломились ночью в магазин с рюкзаком, и перед вами некоторое множество товаров, которые вы можете украсть. Но при этом вместимость рюкзака ограничена — не более 30 условных единиц. В тоже время вы хотите унести набор товаров максимальной стоимости, которые только влезут в рюкзак.

Как вы определите, что положить?

Итак, жадный алгоритм для задачи о рюкзаке состоит в следующих шагах (считаем, что все предметы помещаются в рюкзак):
Выбрать максимально дорогой предмет из еще не затронутых.
Если он помещается в рюкзак, положить его туда, если нет — пропускаем.
Все предметы перебрали? Если нет — возвращаемся к 1 пункту, если да — бежим из магазина, так как наша цель тут выполнена.


Тут ничего особого: три поля — name, weight, cost — для задания характеристик предмета.
Также, как вы можете видеть, тут реализован интерфейс Comparable таким образом, чтобы мы могли сортировать наши Item по цене.
maxWeight — вместимость нашего рюкзака, которая задаётся при создании объекта;
items — объекты находящиеся в рюкзаке;
currentWeight, currentCost — текущий вес и стоимость всех вещей в рюкзаке, которые мы увеличиваем при добавлении нового предмета в методе addItem.
Для начала мы создаем список элементов, сортируем его. Создаем объект сумки с вместимость 30 единиц.
Далее отправляем элементы и объект сумки в метод fillBackpack, в котором, собственно, и заполняется рюкзак по жадному алгоритму:
Всё предельно просто: мы начинаем проходить по отсортированному по стоимости списку элементов и складывать их в сумку, если позволяет вместимость. Если же не позволяет, элемент будет пропущен и продолжится проход по остальным элементам до конца списка.

Запустив main, мы получим вывод в консоль:

Вес рюкзака составляет - 29, общая стоимость вещей в рюкзаке - 3700

Собственно, это и есть пример жадного алгоритма: на каждом шагу выбирается локально-оптимальное решение, а в итоге вы получаете глобально-оптимальное решение.

В нашем случае оптимальный вариант — это наиболее дорогой предмет.

Но является ли это лучшим решением? Вам не кажется, что можно немного модернизировать наше решение, чтобы можно было укомплектовать рюкзак с более высокой суммарной стоимостью?

Давайте взглянем, как это можно сделать:

public static void effectiveFillBackpack(Bag bag, List<Item> items) {
   Map<Double, Item> sortByRatio = new TreeMap(Collections.reverseOrder());
   for (Item item : items) {
       sortByRatio.put((double)item.getCost() / item.getWeight(), item);
   }

   for (Map.Entry<Double, Item> entry : sortByRatio.entrySet()) {
       if(bag.getMaxWeight() > bag.getCurrentWeight() + entry.getValue().getWeight()) {
           bag.addItem(entry.getValue());
       }
   }
}

Тут мы в первую очередь вычисляем соотношение веса и цены для каждого предмета. Так сказать, сколько стоит одна единица данного предмета. И уже по этим значениям мы сортируем наши предметы и добавляем в нашу сумку.

Запустим:

Bag secondBag = new Bag(30);

effectiveFillBackpack(secondBag, items);

System.out.println("Вес рюкзака составляет - " + secondBag.getCurrentWeight() +
       ", общая стоимость вещей в рюкзаке - " + secondBag.getCurrentCost());

Получаем вывод в консоль:

Вес рюкзака составляет - 29, общая стоимость вещей в рюкзаке - 4150

Немного лучше, не правда ли?

Жадный алгоритм  на каждом шагу делает локально оптимальный выбор в расчете на то, что итоговое решение также будет оптимальным. Это не всегда оправдано, но для многих задач жадные алгоритмы действительно дают оптимум.

Временная сложность данного алгоритма — O(N), довольно неплохо, не так ли?